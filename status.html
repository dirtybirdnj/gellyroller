<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gellyroller</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; }

        /* Light theme (default) */
        :root {
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e8e8e8;
            --text-primary: #222;
            --text-secondary: #666;
            --accent: #007700;
            --accent-glow: none;
            --border: #ccc;
            --btn-primary-bg: #0a0;
            --btn-primary-text: #fff;
            --btn-secondary-bg: #ddd;
            --btn-secondary-text: #333;
            --btn-warning-bg: #f90;
            --btn-warning-text: #000;
            --btn-danger-bg: #c00;
            --btn-danger-text: #fff;
            --log-error: #c00;
            --log-success: #070;
            --log-info: #666;
            --progress-bg: #ddd;
            --progress-fill: linear-gradient(90deg, #0a0, #070);
            --canvas-bg: #fff;
            --canvas-grid: #eee;
            --canvas-pending: #ccc;
            --canvas-complete: #0a0;
            --canvas-current: #f00;
        }

        /* Dark theme */
        [data-theme="dark"] {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #0d1b2a;
            --text-primary: #eee;
            --text-secondary: #888;
            --accent: #0f0;
            --accent-glow: 0 0 10px #0f0;
            --border: #333;
            --btn-primary-bg: #0f0;
            --btn-primary-text: #000;
            --btn-secondary-bg: #333;
            --btn-secondary-text: #fff;
            --btn-warning-bg: #f90;
            --btn-warning-text: #000;
            --btn-danger-bg: #f00;
            --btn-danger-text: #fff;
            --log-error: #f00;
            --log-success: #0f0;
            --log-info: #888;
            --progress-bg: #0d1b2a;
            --progress-fill: linear-gradient(90deg, #0f0, #0a0);
            --canvas-bg: #0d1b2a;
            --canvas-grid: #1a2a3a;
            --canvas-pending: #445;
            --canvas-complete: #0f0;
            --canvas-current: #f00;
        }

        body {
            font-family: 'Courier New', monospace;
            background: var(--bg-primary);
            color: var(--text-primary);
            display: grid;
            grid-template-rows: auto 1fr auto;
            height: 100vh;
            padding: 6px;
            gap: 6px;
        }

        /* Header */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 12px;
            background: var(--bg-secondary);
            border-radius: 6px;
            border: 1px solid var(--border);
        }
        header h1 { font-size: 18px; color: var(--accent); }
        .header-controls { display: flex; align-items: center; gap: 12px; font-size: 11px; }
        .header-controls button {
            color: var(--text-secondary);
            cursor: pointer;
            background: none;
            border: none;
            font-family: inherit;
            font-size: 11px;
            padding: 4px 8px;
        }
        .header-controls button:hover { color: var(--accent); }
        .status-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 4px;
        }
        .status-dot.connected { background: var(--accent); box-shadow: var(--accent-glow); }
        .status-dot.disconnected { background: #c00; }

        /* Main content grid - 2 columns */
        main {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            min-height: 0;
            overflow: hidden;
        }

        .panel {
            background: var(--bg-secondary);
            border-radius: 6px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            border: 1px solid var(--border);
            overflow: hidden;
        }
        .panel h2 {
            font-size: 11px;
            color: var(--accent);
            border-bottom: 1px solid var(--border);
            padding-bottom: 4px;
            margin-bottom: 6px;
        }

        /* Left column */
        .left-column {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Canvas visualization */
        .canvas-container {
            flex: 1;
            position: relative;
            min-height: 0;
        }
        #gcodeCanvas {
            width: 100%;
            height: 100%;
            background: var(--canvas-bg);
            border-radius: 4px;
        }
        .canvas-overlay {
            position: absolute;
            bottom: 5px;
            left: 5px;
            font-size: 9px;
            color: var(--text-secondary);
            background: var(--bg-secondary);
            padding: 2px 6px;
            border-radius: 3px;
            opacity: 0.9;
        }

        /* Right column */
        .right-column {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Stats grid with position */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
        }
        .stat {
            background: var(--bg-tertiary);
            padding: 6px 4px;
            border-radius: 4px;
            text-align: center;
        }
        .stat label { font-size: 8px; color: var(--text-secondary); display: block; text-transform: uppercase; }
        .stat .value { font-size: 13px; color: var(--accent); font-weight: bold; }
        .stat.position .value { font-size: 12px; }

        /* Controls */
        .controls {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 4px;
        }
        button {
            padding: 8px 4px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 10px;
            font-weight: bold;
            transition: all 0.2s;
        }
        button:disabled { opacity: 0.3; cursor: not-allowed; }
        .btn-primary { background: var(--btn-primary-bg); color: var(--btn-primary-text); }
        .btn-secondary { background: var(--btn-secondary-bg); color: var(--btn-secondary-text); }
        .btn-warning { background: var(--btn-warning-bg); color: var(--btn-warning-text); }
        .btn-danger { background: var(--btn-danger-bg); color: var(--btn-danger-text); }

        /* Job info */
        .job-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }
        .job-filename { font-size: 12px; color: var(--btn-warning-bg); }
        .job-status { font-size: 10px; color: var(--text-secondary); }
        .progress-bar {
            height: 14px;
            background: var(--progress-bg);
            border-radius: 7px;
            overflow: hidden;
            margin: 4px 0;
        }
        .progress-fill {
            height: 100%;
            background: var(--progress-fill);
            transition: width 0.3s;
        }
        .progress-text {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            color: var(--text-secondary);
        }

        /* Layers */
        .layers-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            max-height: 50px;
            overflow-y: auto;
        }
        .layer {
            padding: 2px 5px;
            background: var(--bg-tertiary);
            border-radius: 3px;
            font-size: 9px;
            border: 1px solid var(--border);
        }
        .layer.active { background: #ff0; color: #000; }
        .layer.completed { background: var(--accent); color: #fff; }

        /* Upload area */
        .upload-row {
            display: flex;
            gap: 4px;
            align-items: center;
        }
        .upload-row input[type="file"] { flex: 1; font-size: 9px; }
        textarea {
            flex: 1;
            min-height: 50px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 6px;
            font-family: inherit;
            font-size: 9px;
            resize: none;
            border-radius: 4px;
        }
        .upload-buttons {
            display: flex;
            gap: 4px;
        }
        .upload-buttons button { flex: 1; }

        /* Log */
        #log {
            flex: 1;
            overflow-y: auto;
            background: var(--bg-tertiary);
            padding: 4px;
            font-size: 8px;
            border-radius: 4px;
            line-height: 1.3;
            min-height: 40px;
        }
        #log .error { color: var(--log-error); }
        #log .success { color: var(--log-success); }
        #log .info { color: var(--log-info); }

        /* Footer */
        footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 12px;
            background: var(--bg-secondary);
            border-radius: 6px;
            font-size: 9px;
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }
        footer a { color: var(--accent); text-decoration: none; }
    </style>
</head>
<body>
    <header>
        <h1>GELLYROLLER</h1>
        <div class="header-controls">
            <span>
                <span id="wsStatus" class="status-dot disconnected"></span>
                <span id="wsStatusText">Connecting...</span>
            </span>
            <button onclick="toggleFullscreen()">Fullscreen</button>
            <button onclick="toggleTheme()">Theme</button>
        </div>
    </header>

    <main>
        <!-- Left: Visualization -->
        <div class="left-column">
            <div class="panel" style="flex: 1;">
                <h2>PREVIEW</h2>
                <div class="canvas-container">
                    <canvas id="gcodeCanvas"></canvas>
                    <div class="canvas-overlay">
                        <span id="canvasSize">480 x 480 mm</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right: Controls & Info -->
        <div class="right-column">
            <!-- Stats row with position -->
            <div class="panel">
                <h2>STATUS</h2>
                <div class="stats-grid">
                    <div class="stat position"><label>X</label><div class="value" id="posX">--</div></div>
                    <div class="stat position"><label>Y</label><div class="value" id="posY">--</div></div>
                    <div class="stat"><label>Lines</label><div class="value" id="statLines">--</div></div>
                    <div class="stat"><label>Moves</label><div class="value" id="statMoves">--</div></div>
                    <div class="stat"><label>Progress</label><div class="value" id="progressPercent">0%</div></div>
                    <div class="stat"><label>Elapsed</label><div class="value" id="elapsed">--</div></div>
                    <div class="stat"><label>Remaining</label><div class="value" id="remaining">--</div></div>
                    <div class="stat"><label>Est. Time</label><div class="value" id="statTime">--</div></div>
                </div>
            </div>

            <!-- Controls -->
            <div class="panel">
                <h2>CONTROLS</h2>
                <div class="controls">
                    <button class="btn-primary" onclick="home()">HOME</button>
                    <button class="btn-secondary" onclick="getPosition()">REFRESH</button>
                    <button id="btnPause" class="btn-warning" onclick="pauseJob()" disabled>PAUSE</button>
                    <button id="btnResume" class="btn-primary" onclick="resumeJob()" disabled>RESUME</button>
                    <button id="btnCancel" class="btn-secondary" onclick="cancelJob()" disabled>CANCEL</button>
                    <button class="btn-danger" onclick="emergencyStop()">E-STOP</button>
                </div>
            </div>

            <!-- Job info -->
            <div class="panel">
                <h2>JOB</h2>
                <div class="job-header">
                    <span class="job-filename" id="jobFilename">No job loaded</span>
                    <span class="job-status" id="jobStatus">--</span>
                </div>
                <div class="progress-bar">
                    <div id="progressFill" class="progress-fill" style="width: 0%"></div>
                </div>
                <div class="progress-text">
                    <span>Line <span id="currentLine">0</span>/<span id="totalLines">0</span></span>
                    <span>Layer <span id="currentLayer">0</span>/<span id="totalLayers">0</span></span>
                </div>
                <div id="layersContainer" class="layers-grid" style="margin-top: 4px;">
                </div>
            </div>

            <!-- Upload -->
            <div class="panel" style="flex: 1;">
                <h2>UPLOAD G-CODE</h2>
                <div class="upload-row">
                    <input type="file" id="fileInput" accept=".gcode,.g,.nc">
                </div>
                <textarea id="gcodeInput" placeholder="Or paste G-code here..."></textarea>
                <div class="upload-buttons">
                    <button class="btn-secondary" onclick="uploadJob()">UPLOAD</button>
                    <button id="btnStart" class="btn-primary" onclick="startJob()" disabled>START</button>
                </div>
            </div>

            <!-- Log -->
            <div class="panel">
                <h2>LOG</h2>
                <div id="log"></div>
            </div>
        </div>
    </main>

    <footer>
        <span>Gellyroller Pen Plotter</span>
        <span>
            <a href="https://github.com/dirtybirdnj/gellyroller" target="_blank">GitHub</a> |
            <a href="https://github.com/dirtybirdnj/gellyroller#readme" target="_blank">Docs</a>
        </span>
    </footer>

    <script>
        // Config
        const MACHINE_WIDTH = 480;
        const MACHINE_HEIGHT = 480;

        // Canvas state
        let canvas, ctx;
        let gcodeLines = [];
        let parsedMoves = [];
        let currentLineIndex = 0;

        // Animation state
        let animationId = null;
        let animatedPos = { x: 200, y: 200 };
        let targetPos = { x: 200, y: 200 };
        let moveStartTime = 0;
        let moveDuration = 0;
        let moveStartPos = { x: 200, y: 200 };
        let currentFeedRate = 2000; // mm/min default

        // Theme
        function toggleTheme() {
            const current = document.documentElement.getAttribute('data-theme');
            document.documentElement.setAttribute('data-theme', current === 'dark' ? '' : 'dark');
            localStorage.setItem('theme', current === 'dark' ? 'light' : 'dark');
            drawCanvas();
        }
        function loadTheme() {
            if (localStorage.getItem('theme') === 'dark') {
                document.documentElement.setAttribute('data-theme', 'dark');
            }
        }

        // Fullscreen
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        // Canvas setup
        function initCanvas() {
            canvas = document.getElementById('gcodeCanvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        }

        function resizeCanvas() {
            const container = canvas.parentElement;
            const size = Math.min(container.clientWidth, container.clientHeight);
            canvas.width = size;
            canvas.height = size;
            drawCanvas();
        }

        function drawCanvas() {
            if (!ctx) return;
            const w = canvas.width;
            const h = canvas.height;
            const scale = Math.min(w, h) / Math.max(MACHINE_WIDTH, MACHINE_HEIGHT);
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';

            // Background
            ctx.fillStyle = isDark ? '#0d1b2a' : '#fff';
            ctx.fillRect(0, 0, w, h);

            // Grid
            ctx.strokeStyle = isDark ? '#1a2a3a' : '#eee';
            ctx.lineWidth = 1;
            const gridSize = 50 * scale;
            for (let x = 0; x <= w; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }
            for (let y = 0; y <= h; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }

            // Border
            ctx.strokeStyle = isDark ? '#333' : '#ccc';
            ctx.lineWidth = 2;
            ctx.strokeRect(1, 1, w - 2, h - 2);

            // Draw moves
            if (parsedMoves.length > 0) {
                // Pending moves (gray)
                ctx.strokeStyle = isDark ? '#445' : '#ccc';
                ctx.lineWidth = 1;
                ctx.beginPath();
                for (let i = currentLineIndex; i < parsedMoves.length; i++) {
                    const move = parsedMoves[i];
                    if (move.type === 'move') {
                        ctx.moveTo(move.fromX * scale, h - move.fromY * scale);
                    } else if (move.type === 'draw') {
                        ctx.moveTo(move.fromX * scale, h - move.fromY * scale);
                        ctx.lineTo(move.toX * scale, h - move.toY * scale);
                    }
                }
                ctx.stroke();

                // Completed moves (green)
                ctx.strokeStyle = isDark ? '#0f0' : '#0a0';
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < currentLineIndex && i < parsedMoves.length; i++) {
                    const move = parsedMoves[i];
                    if (move.type === 'draw') {
                        ctx.moveTo(move.fromX * scale, h - move.fromY * scale);
                        ctx.lineTo(move.toX * scale, h - move.toY * scale);
                    }
                }
                ctx.stroke();

                // Current position marker
                if (currentLineIndex > 0 && currentLineIndex <= parsedMoves.length) {
                    const lastMove = parsedMoves[Math.min(currentLineIndex, parsedMoves.length) - 1];
                    const px = (lastMove.toX || lastMove.fromX) * scale;
                    const py = h - (lastMove.toY || lastMove.fromY) * scale;
                    ctx.fillStyle = '#f00';
                    ctx.beginPath();
                    ctx.arc(px, py, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Animated current position from machine
            if (animatedPos.x != null && animatedPos.y != null) {
                const px = animatedPos.x * scale;
                const py = h - animatedPos.y * scale;

                // Draw trail effect (fading circles)
                ctx.fillStyle = 'rgba(0, 100, 255, 0.2)';
                ctx.beginPath();
                ctx.arc(px, py, 12, 0, Math.PI * 2);
                ctx.fill();

                // Main position dot
                ctx.fillStyle = '#00f';
                ctx.beginPath();
                ctx.arc(px, py, 5, 0, Math.PI * 2);
                ctx.fill();

                // Outer ring
                ctx.strokeStyle = '#00f';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(px, py, 8, 0, Math.PI * 2);
                ctx.stroke();

                // Direction indicator (if moving)
                if (animationId && targetPos.x !== animatedPos.x || targetPos.y !== animatedPos.y) {
                    const tx = targetPos.x * scale;
                    const ty = h - targetPos.y * scale;
                    ctx.strokeStyle = 'rgba(0, 100, 255, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.moveTo(px, py);
                    ctx.lineTo(tx, ty);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }

        // Parse G-code for visualization with timing
        function parseGcode(gcode) {
            parsedMoves = [];
            let x = 0, y = 0;
            let penDown = false;
            let feedRate = 2000; // Default mm/min

            const lines = gcode.split('\n');
            for (const line of lines) {
                const clean = line.split(';')[0].trim().toUpperCase();
                if (!clean) continue;

                // Pen control
                if (clean.includes('M42') && clean.includes('P0')) {
                    penDown = clean.includes('S1');
                    continue;
                }

                // Movement
                const gMatch = clean.match(/^G([01])\s/);
                if (gMatch) {
                    const isRapid = gMatch[1] === '0';
                    const xMatch = clean.match(/X([-\d.]+)/);
                    const yMatch = clean.match(/Y([-\d.]+)/);
                    const fMatch = clean.match(/F([\d.]+)/);

                    if (fMatch) feedRate = parseFloat(fMatch[1]);

                    const newX = xMatch ? parseFloat(xMatch[1]) : x;
                    const newY = yMatch ? parseFloat(yMatch[1]) : y;

                    if (xMatch || yMatch) {
                        // Calculate distance and duration
                        const dx = newX - x;
                        const dy = newY - y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        // Rapid moves (G0) use max speed, G1 uses feed rate
                        const effectiveFeedRate = isRapid ? 6000 : feedRate;
                        const durationMs = (distance / effectiveFeedRate) * 60 * 1000;

                        parsedMoves.push({
                            type: penDown ? 'draw' : 'move',
                            fromX: x,
                            fromY: y,
                            toX: newX,
                            toY: newY,
                            feedRate: effectiveFeedRate,
                            distance: distance,
                            durationMs: durationMs
                        });
                        x = newX;
                        y = newY;
                    }
                }
            }

            currentLineIndex = 0;
            drawCanvas();
        }

        // WebSocket
        let ws = null;
        let currentJobId = null;

        function connect() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${location.host}/ws`;
            log(`Connecting...`, 'info');
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                log('Connected', 'success');
                document.getElementById('wsStatus').className = 'status-dot connected';
                document.getElementById('wsStatusText').textContent = 'Connected';
                if (currentJobId) {
                    ws.send(JSON.stringify({ type: 'subscribe', data: { jobId: currentJobId } }));
                }
            };

            ws.onmessage = (e) => handleMessage(JSON.parse(e.data));

            ws.onclose = () => {
                document.getElementById('wsStatus').className = 'status-dot disconnected';
                document.getElementById('wsStatusText').textContent = 'Disconnected';
                setTimeout(connect, 3000);
            };

            ws.onerror = () => log('WebSocket error', 'error');
        }

        function handleMessage(msg) {
            switch (msg.type) {
                case 'position:update':
                    updatePosition(msg.data);
                    break;
                case 'job:started':
                    log('Job started', 'success');
                    document.getElementById('jobStatus').textContent = 'Running';
                    updateButtons('running');
                    break;
                case 'job:progress':
                    updateProgress(msg.data);
                    break;
                case 'job:paused':
                    document.getElementById('jobStatus').textContent = 'Paused';
                    updateButtons('paused');
                    break;
                case 'job:resumed':
                    document.getElementById('jobStatus').textContent = 'Running';
                    updateButtons('running');
                    break;
                case 'job:completed':
                    log(`Completed in ${formatTime(msg.data.elapsedMs)}`, 'success');
                    document.getElementById('jobStatus').textContent = 'Done';
                    document.getElementById('progressFill').style.width = '100%';
                    document.getElementById('progressPercent').textContent = '100%';
                    currentLineIndex = parsedMoves.length;
                    drawCanvas();
                    updateButtons('completed');
                    break;
                case 'job:error':
                    log(`Error: ${msg.data.error}`, 'error');
                    document.getElementById('jobStatus').textContent = 'Error';
                    updateButtons('error');
                    break;
            }
        }

        function updatePosition(pos) {
            document.getElementById('posX').textContent = pos.x?.toFixed(1) ?? '--';
            document.getElementById('posY').textContent = pos.y?.toFixed(1) ?? '--';

            // Calculate distance to new position
            const dx = pos.x - animatedPos.x;
            const dy = pos.y - animatedPos.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 0.5) {
                // Start animated move
                moveStartPos = { ...animatedPos };
                targetPos = { x: pos.x, y: pos.y };
                moveStartTime = performance.now();
                // Estimate duration based on distance and typical feed rate
                moveDuration = (distance / currentFeedRate) * 60 * 1000;
                // Minimum 50ms, maximum 2000ms for smooth animation
                moveDuration = Math.max(50, Math.min(moveDuration, 2000));

                if (!animationId) {
                    animationId = requestAnimationFrame(animatePosition);
                }
            } else {
                animatedPos = { x: pos.x, y: pos.y };
                drawCanvas();
            }
        }

        function animatePosition(timestamp) {
            const elapsed = timestamp - moveStartTime;
            const progress = Math.min(elapsed / moveDuration, 1);

            // Ease-out for smooth deceleration
            const eased = 1 - Math.pow(1 - progress, 2);

            animatedPos.x = moveStartPos.x + (targetPos.x - moveStartPos.x) * eased;
            animatedPos.y = moveStartPos.y + (targetPos.y - moveStartPos.y) * eased;

            drawCanvas();

            if (progress < 1) {
                animationId = requestAnimationFrame(animatePosition);
            } else {
                animatedPos = { ...targetPos };
                animationId = null;
                drawCanvas();
            }
        }

        function updateProgress(data) {
            document.getElementById('progressFill').style.width = data.percentage + '%';
            document.getElementById('progressPercent').textContent = data.percentage + '%';
            document.getElementById('currentLine').textContent = data.currentLine;
            document.getElementById('totalLines').textContent = data.totalLines;
            document.getElementById('currentLayer').textContent = data.currentLayer + 1;
            document.getElementById('elapsed').textContent = formatTime(data.elapsedMs);
            document.getElementById('remaining').textContent = formatTime(data.estimatedRemainingMs);

            // Update canvas progress
            const newLineIndex = Math.floor(data.currentLine * parsedMoves.length / data.totalLines);

            // Update current feed rate from parsed moves for accurate animation
            if (newLineIndex < parsedMoves.length && parsedMoves[newLineIndex]) {
                currentFeedRate = parsedMoves[newLineIndex].feedRate || 2000;
            }

            currentLineIndex = newLineIndex;
            drawCanvas();

            highlightLayer(data.currentLayer);
        }

        function highlightLayer(index) {
            document.querySelectorAll('.layer').forEach((el, i) => {
                el.classList.remove('active', 'completed');
                if (i === index) el.classList.add('active');
                else if (i < index) el.classList.add('completed');
            });
        }

        function updateButtons(status) {
            document.getElementById('btnPause').disabled = status !== 'running';
            document.getElementById('btnResume').disabled = status !== 'paused';
            document.getElementById('btnCancel').disabled = status !== 'running' && status !== 'paused';
            document.getElementById('btnStart').disabled = status === 'running';
        }

        function formatTime(ms) {
            if (!ms || ms < 0) return '--';
            const s = Math.floor(ms / 1000);
            const m = Math.floor(s / 60);
            return `${m}:${(s % 60).toString().padStart(2, '0')}`;
        }

        function log(msg, type = '') {
            const el = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            el.innerHTML += `<div class="${type}">[${time}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        async function api(method, path, body = null) {
            const opts = { method, headers: { 'Content-Type': 'application/json' } };
            if (body) opts.body = JSON.stringify(body);
            return (await fetch(path, opts)).json();
        }

        async function getPosition() {
            const result = await api('GET', '/position');
            if (result.success) updatePosition(result.data);
        }

        async function home() {
            log('Homing...', 'info');
            await api('POST', '/home');
        }

        async function emergencyStop() {
            if (confirm('EMERGENCY STOP?')) {
                log('E-STOP', 'error');
                await api('POST', '/emergency-stop');
            }
        }

        async function uploadJob() {
            const fileInput = document.getElementById('fileInput');
            const gcodeInput = document.getElementById('gcodeInput');

            let filename = 'upload.gcode';
            let content = gcodeInput.value;

            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                filename = file.name;
                content = await file.text();
            }

            if (!content.trim()) {
                alert('No G-code');
                return;
            }

            // Parse for preview
            parseGcode(content);

            log(`Uploading ${filename}...`, 'info');
            const result = await api('POST', '/job/upload', { filename, content });

            if (result.success) {
                currentJobId = result.data.jobId;
                log(`Ready: ${currentJobId.slice(0, 8)}`, 'success');

                document.getElementById('jobFilename').textContent = filename;
                document.getElementById('jobStatus').textContent = 'Ready';
                document.getElementById('totalLines').textContent = result.data.stats.totalLines;
                document.getElementById('totalLayers').textContent = result.data.layers.length;
                document.getElementById('statLines').textContent = result.data.stats.totalLines;
                document.getElementById('statMoves').textContent = result.data.stats.movementCommands;
                document.getElementById('statTime').textContent = formatTime(result.data.stats.estimatedTimeMs);

                const layersEl = document.getElementById('layersContainer');
                layersEl.innerHTML = result.data.layers.map((l, i) =>
                    `<div class="layer">${l.name || 'L' + (i+1)}</div>`
                ).join('');

                if (ws?.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'subscribe', data: { jobId: currentJobId } }));
                }

                document.getElementById('btnStart').disabled = false;
            } else {
                log(`Failed: ${result.error}`, 'error');
            }
        }

        async function startJob() {
            if (!currentJobId) return;
            log('Starting...', 'info');
            const result = await api('POST', `/job/${currentJobId}/start`);
            if (result.success) {
                document.getElementById('jobStatus').textContent = 'Running';
                updateButtons('running');
            } else {
                log(`Failed: ${result.error}`, 'error');
            }
        }

        async function pauseJob() {
            if (currentJobId) await api('POST', `/job/${currentJobId}/pause`);
        }

        async function resumeJob() {
            if (currentJobId) await api('POST', `/job/${currentJobId}/resume`);
        }

        async function cancelJob() {
            if (currentJobId && confirm('Cancel?')) {
                await api('POST', `/job/${currentJobId}/cancel`);
            }
        }

        // Init
        loadTheme();
        initCanvas();
        connect();
        getPosition();
        setInterval(getPosition, 5000);
    </script>
</body>
</html>
